%%% ml.tex, main file of TeX paper

\documentclass{article}
\usepackage{latexsym}
\usepackage{amsfonts,amssymb}
\usepackage{mathrsfs}
\usepackage[hidelinks]{hyperref}
\usepackage{amsthm}
\usepackage{cleveref}
\usepackage{mfirstuc}
\usepackage{numname}
\usepackage{proof}
\usepackage{ifthen}
\usepackage{listings}

\usepackage[numbers,longnamesfirst]{natbib}
\usepackage{doi}
\def\doitext{DOI }
\bibliographystyle{plainnat}

\newcommand\TVs{V}   % metavariable for the set of truth values

\makeatletter
\newcount\ml@tmp
\newcommand\FOR{}
\newcommand\@FOR{}
\newcommand\@FORnext{}
\def\FOR#1{\newcommand#1{}\@FOR#1}
\long\def\@FOR#1=#2\TO#3\DO#4\ENDFOR
   {\edef#1{#2}%
    \ifnum#1>#3%
       \let\@FORnext\relax
       \let#1\relax
    \else
       \ml@tmp=#2%
       \advance\ml@tmp by 1%
       \def\@FORnext{\@FOR#1=\number\ml@tmp\TO#3\DO#4\ENDFOR}%
       #4%
    \fi
    \@FORnext
   }

\def\texExtra#1#2#3{\@ifundefined{#1}{#3}{#2}}
\makeatother

\newcommand\TV     [1]{\csname TV\romannumeral#1\endcsname}
\newcommand\Opname [1]{\csname Opname\romannumeral#1\endcsname}
\newcommand\Oparity[1]{\csname Oparity\romannumeral#1\endcsname}
\newcommand\Opfmla [1]{\csname Opfmla\romannumeral#1\endcsname}
\newcommand\Optab  [1]{\csname Optab\romannumeral#1\endcsname}
\newcommand\Opconcl[2]{\csname Opconcl\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\Opprems[2]{\csname Opprems\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\NDOpconcl[2]{\csname NDOpconcl\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\NDOpprems[2]{\csname NDOpprems\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\ClOpconcl[2]{\csname ClOpconcl\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\ClOpprem [2]{\csname
ClOpprem\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\TabOpconcl[2]{\csname TabOpconcl\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\TabOpprem [2]{\csname TabOpprem\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\PnfOpL[2]{\csname PnfOpL\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\PnfOpR[2]{\csname PnfOpR\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\Quname [1]{\csname Quname\romannumeral#1\endcsname}
\newcommand\Qutab  [1]{\csname Qutab\romannumeral#1\endcsname}
\newcommand\Quconcl[2]{\csname Quconcl\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\Quprems[2]{\csname Quprems\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\NDQuconcl[2]{\csname NDQuconcl\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\NDQuprems[2]{\csname NDQuprems\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\ClQuconcl[2]{\csname ClQuconcl\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\ClQuprem [2]{\csname
ClQuprem\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\TabQuconcl[2]{\csname TabQuconcl\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\TabQuprem [2]{\csname TabQuprem\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\PnfQuL[2]{\csname PnfQuL\romannumeral#1X\romannumeral#2\endcsname}
\newcommand\PnfQuR[2]{\csname PnfQuR\romannumeral#1X\romannumeral#2\endcsname}

\newcommand\PS[1]{\ifnum#1>1s\fi}            % Plural "s"
\newcommand\ARE[1]{\ifnum#1>1are\else is\fi}

\newcommand\IfIsDTV[1]{\csname ifTV\romannumeral #1IsDTV\endcsname}
\newcommand\NDEI[1]{\IfIsDTV{#1}\textsc{i}\else \textsc{e}\fi}

\newcommand\ClauseSet{\mathscr{C}}
\newcommand\Clause{C}

\def\tbox{\widetilde{\vphantom{l}\Box}}
\def\tdiamond{\widetilde{\vphantom{l}\Diamond}}
\def\toperator{\widetilde{\vphantom{l}\operator}}
\def\tquantor{\widetilde{\vphantom{l}\quantor}}

\def\C{\ensuremath{\mathscr{C}}}
\def\D{\ensuremath{\mathscr{D}}}
\def\E{\ensuremath{\mathscr{E}}}
\def\cally#1{\ensuremath{\mathscr{#1}}}
\def\H{{\bf H}}
\def\I{{\bf I}}
\def\SC{{\bf SC}}
\def\ISC{{\bf ISC}}
\def\LK{{\bf LK}}
\def\PL{{\bf PL}}
\def\Form{{\rm Form}}

\let\impl\supset
\def\M{\ensuremath{\mathscr{M}}}
\def\val{{\rm val}}

\def\quantor{{\ensuremath{\sf Q}}}
\def\operator{\ensuremath{\Box}}
\def\LL{\ensuremath{\mathscr{L}}}

\def\ifprop{\ifnum\NoQus=0}    % Is the logic purely propositional?
\def\ifnotprop{\ifnum\NoQus>0}
\def\TVss{\TV1\FOR\n=2\TO\NoTVs\DO,\TV\n\ENDFOR}
\newcommand\DTV[1]{\IfIsDTV{#1}\loopcomma\TV{#1}\def\loopcomma{, }\fi}%
\def\DTVss{\def\loopcomma{}%
\FOR\n=1\TO\NoTVs\DO%
   \DTV{\n}%
   \ENDFOR}
\newcommand\NDTV[1]{\IfIsDTV{#1}\else\loopcomma\TV{#1}\def\loopcomma{, }\fi}%
\def\NDTVss{\def\loopcomma{}%
   \FOR\n=1\TO\NoTVs\DO%
      \NDTV{\n}%
      \ENDFOR}

%%% Theorem environments

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

% TeX commands specific to the particular logic; written by "ml_tex.pl".
\usepackage{\jobname}

\texExtra{FullNameOfLogic}{\let\NameOfLogic\FullNameOfLogic}{\apptocmd{\NameOfLogic}{\ logic}{}{}}

\title{Analytic Proof Systems for \ecapitalisewords{\NameOfLogic}%
\texExtra{ShortName}{~\ensuremath{\ShortName}}{\relax}}

\author{M.~Ultlog\thanks{Cite as: Multlog (\Year), ``Analytic proof
systems for
{\NameOfLogic}\texExtra{ShortName}{~\ensuremath{\ShortName}}{\relax}.''
[PDF file generated by MULTLOG, v.~@ml_version@,
\url{https://logic.at/multlog}]. \texExtra{Link}{Available from
\url{\Link}.}{}\newline\newline See
\IfFileExists{\jobname.cfg}{\cref{lgc,cfg}}{\cref{lgc}} for the
specification of {\NameOfLogic}.}}

\makeatletter
\hypersetup{pdftitle={\@title},pdfauthor={\@author},pdfkeywords={\NameOfLogic, sequent calculus, tableaux, natural deduction, resolution}}

\texExtra{Preamble}{\Preamble}{\relax}

\makeatother


\begin{document}

\maketitle

\begin{abstract}
We give sequent calculus, analytic tableaux, natural deduction, and
clause translation systems for resolution for
\NameOfLogic\texExtra{ShortName}{~\ensuremath{\ShortName}}{\relax}.
\end{abstract}

\section{Introduction}

In this paper we present calculi for
\NameOfLogic{}\texExtra{ShortName}{~\ensuremath{\ShortName}}{}%
\makeatletter\@ifundefined{b@ml}{}{ \citep{ml}}\makeatother.
\emakefirstuc{\NameOfLogic} has \numtoname{\NoTVs} truth values
$\TVss$ (with $\DTVss$ designated), \ifnum\NoQus=0 and
\fi
\ifnum\NoOps>0
   connective\PS{\NoOps}
   $\Opname1$%
   \FOR \n=2 \TO \NoOps \DO
      , $\Opname\n$%
   \ENDFOR
\fi
\ifnum\NoQus>0
   , and quantifier\PS{\NoQus}
   $\Quname1$%
   \FOR \n=2 \TO \NoQus \DO
      , $\Quname\n$%
   \ENDFOR
\fi. Its syntax and semantics is detailed in \cref{sec:prelim}.

\texExtra{Intro}{\Intro}{\relax}

We first present a \NoTVs-sided sequent calculus in
\cref{sec:sequent}. The fundamental idea for many-sided sequent
calculi for finite-valued logics goes back to
\citet{Schroter1955,Rousseau1967,Takahashi1968}. We follow the method
given by \citet{BaazFermullerZach1994} and \citet{Zach1993} for
constructing inference rules. This guarantees that our system
automatically has cut-elimination\ifnotprop, mid-sequent theorem,\fi\
and Maehara lemma.

Signed tableau systems for finite-valued logics were proposed by
\citet{Surma1977} and \citet{Carnielli1987}, and generalized by
\citet{Hahnle1993}. In \cref{sec:tableaux}, we present a signed
tableau system for \NameOfLogic.

Many-valued natural deduction systems for finite-valued logics have
been investigated by \citet{BaazFermullerZach1993b} and
\citet{Zach1993}. We give the introduction and elimination rules for
the natural deduction system for \NameOfLogic{} in
\cref{sec:natural}.

In addition to H\"ahnle's work on tableaux-based theorem proving for
finite-valued logic, \citet{OHearnStachniak1992} and
\citet{BaazFermuller1995} have studied resolution calculi. In order
for these calculi to be used to prove that formulas of \NameOfLogic\
are \ifprop valid\else tautologies\fi{} or follow from some others, it
is necessary to produce sets of signed clauses.  In
\cref{sec:clauses}, we present a translation calculus that yields a
set of clauses from a set of formulas. 

The rules we provide are optimal in each case, and use the algorithms
developed by Salzer~\cite{Salzer1996a,Salzer2000}.

\section{Syntax and semantics}\label{sec:prelim}

%%% Language, Terms, Formulae, Conventions
\begin{definition}

% Giving different defs for propositional logic
\ifprop
   The \emph{propositional language~\LL\/} for \NameOfLogic{} consists of
   \begin{enumerate}
   \item propositional variables: $x_0, x_1, x_2, \ldots$
   \ifnum\NoOps>0
   \item
         \ifnum\NoOps>1
            propositional connectives,
         \else
            one propositional connective,
         \fi
         arity given in parenthesis:
         $\Opname1\ (\Oparity1)$
         \FOR \n=2 \TO \NoOps \DO
            \ifnum\n=\NoOps 
               ,~and~%
            \else
               ,
            \fi 
            $\Opname\n$~($\Oparity\n$)%
         \ENDFOR\
   \fi 
   \item auxiliary symbols: ``('', ``)'' and ``,''
   \end{enumerate}

   \ifnum\NoOps=0 
      Every propositional variable and every propositional connective of
      arity~0, called a propositional constant, is a \emph{formula}. It is
      called \emph{atomic} or an \emph{atom}. \NameOfLogic{} only
      contains atomic formulas.
   \else
      \emph{Formulas} are defined inductively:
      \begin{enumerate}
      \item Every propositional variable is a formula.
      \ifnum\NoOps>0
         \FOR \n=1 \TO \NoOps \DO
            \ifcase\numexpr\Oparity\n\relax
               \item The propositional constant $\Opname\n$ is a formula.
            \or
               \item If $A$ is a formula, so is $\Opfmla\n$.
            \or
               \item If $A$ and $B$ are formulas, so is $\Opfmla\n$.
            \else
               \item If $A_1$, \dots, $A_{\Oparity\n}$ are formulas, so is $\Opfmla\n$.
            \fi
         \ENDFOR\
      \fi
      \end{enumerate}
   \fi 
\else
   The \emph{first order language~\LL\/} for \NameOfLogic{}
   consists of
   \begin{enumerate}
   \item free variables: $a_0, a_1, a_2, \ldots$
   \item bound variables: $x_0, x_1, x_2, \ldots$
   \item function symbols of arity $i$ $(i \in \mathbb{N})$, including constants:
         $f_0^i, f_1^i, f_2^i, \ldots$
   \item predicate constants of arity $i$ $(i \in \mathbb{N})$:
         $P_0^i, P_1^i, P_2^i, \ldots$
   \ifnum\NoOps>0 
   \item
         \ifnum\NoOps>1 
            propositional connectives,
         \else
            one propositional connective,
         \fi 
         arity given in parenthesis:
         $\Opname1~(\Oparity1)$
         \FOR \n=2 \TO \NoOps \DO
            \ifnum\n=\NoOps 
               ~and~%
            \else
               ,
            \fi 
            $\Opname\n$~($\Oparity\n$)%
         \ENDFOR\
   \fi 
   \ifnum\NoQus>0 
   \item
         \ifnum\NoQus=1 
            one quantifier:
         \else
            quantifiers:
         \fi 
         $\Quname1$
         \FOR \n=2 \TO \NoQus \DO
            \ifnum\n=\NoQus
               ~and~%
            \else
               ,
            \fi 
            $\Quname\n$
         \ENDFOR\
   \fi 
   \item auxiliary symbols: ``('', ``)'' and ``,''
   \end{enumerate}

   \emph{Terms\/} are defined inductively: Every individual constant and free
   variable is a term. If $f^n$ is a function symbol of arity~$n$,
   and $t_1,\dots,t_n$ are terms, then~$f^n(t_1,\ldots,t_n)$ is a term.

   \emph{Formulas\/} are also defined inductively:
   \begin{enumerate}
   \item If $P^n$ is a predicate symbol of arity~$n$, and
         $t_1,\ldots,t_n$ are terms, then $P^n(t_1,\ldots,t_n)$ is
         a formula. It is called \emph{atomic} or an \emph{atom}.
      \ifnum\NoOps>0
         \FOR \n=1 \TO \NoOps \DO
            \ifcase\numexpr\Oparity\n\relax
               \item The propositional constant $\Opname\n$ is an (atomic) formula.
            \or
               \item If $A$ is a formula, so is $\Opfmla\n$.
            \or
               \item If $A$ and $B$ are formulas, so is $\Opfmla\n$.
            \else
               \item If $A_1$, \dots, $A_{\Oparity\n}$ are formulas, so is $\Opfmla\n$.
            \fi
         \ENDFOR\
      \fi
   \item If~$A$ is a formula not containing the bound
         variable~$x$, $a$~is a free variable and $\quantor$ is a quantifier,
         then $(\quantor x)A(x)$, where $A(x)$ is obtained from $A$ by
         replacing $a$ by~$x$ at every occurrence of~$a$ in~$A$, is a formula.
   \end{enumerate}
   A formula is called \emph{open}, if it contains free variables, and
   \emph{closed} otherwise.  A formula without quantifiers is called {\em
   quantifier-free}.
\fi % 0 End of different defs for prop and non-prop logic.
\end{definition}

As a notational convention, lowercase letters
\ifprop 
   will be used to denote variables, possibly indexed.
\else
   from the beginning of the alphabet ($a, b, c,\ldots$) will be used
   to denote free variables, $f, g, h, \ldots$ for function symbols and
   constants, $x, y, z, \ldots$ for bound variables,
   all possibly indexed.
\fi 
Uppercase letters $A, B, C, \ldots$ will stand
for formulas, greek letters $\Gamma, \Delta, \Lambda, \ldots$ for
sequences and sets of
\ifprop 
   formulas.
\else
   formulas, $t$ and $s$ for terms.
\fi
\ifnum\NoOps>0 
   \ifnum\NoQus>0
      The symbols $\operator$ and $\quantor$ stand for general propositional
      connectives and quantifiers, respectively.
   \else
      The symbol $\operator$ stands for general propositional connectives.
   \fi
\else
   \ifnum\NoQus>0
      The symbol $\quantor$ stands for general quantifiers.
   \fi
\fi

\ifnotprop
   \begin{definition}
   We will use $\alpha$ as a variable for free variables (\emph{eigenvariable})
   and $\tau$ as a variable for terms (\emph{term variable}). A formula
   consisting of some formula variables, eigenvariables and term variables is
   called a schema.

   A \emph{pre-instance\/} $A'$ of a schema $A$ is an actual formula from the
   formulas\ of $\LL$ which contains occurrences of the eigenvariables and
   term variables of~$A$.

   An \emph{instance\/} $A''$ of $A$ is a pre-instance $A'$ of $A$, where the
   eigenvariables and term variables have been replaced by free variables and
   terms not occurring in $A'$.
%%% Example wanted?
% E.g.\ $A(\alpha,\tau)$ is a schema, $B_1(\alpha,x)\lor B_2(\alpha,\tau,y)$
% is a pre-instance of $A$ and $B_1(z,x)\lor B_2(z,f_1(x),y)$ is an instance.
\end{definition}
\fi

\texExtra{Semantics}{\Semantics}{\relax}

%%% Matrix
\begin{definition}
The \emph{matrix} for \NameOfLogic{} is given by:
\begin{enumerate}
\item the set of \emph{truth values}
      $\TVs=\{\TVss\}$,

\item the set $\TVs^+ = \{\DTVss\} \subseteq \TVs$ of \emph{designated truth values},
\ifnum\NoOps>0
   \item 
   the truth function\PS{\NoOps} for connective\PS{\NoOps}
   $\Opname1$%
   \FOR \n=2 \TO \NoOps \DO
      \ifnum\n=\NoOps
         ~and~%
      \else
         ,
      \fi
      $\Opname\n$%
   \ENDFOR, as given below;
\fi
\ifnum\NoQus>0
   \item
   the truth function\PS{\NoQus} for quantifier\PS{\NoQus}
   $\Quname1$%
   \FOR \n=2 \TO \NoQus \DO
      \ifnum\n=\NoQus
         ~and~%
      \else
         ,
      \fi
      $\Quname\n$%
   \ENDFOR, as given below.
\fi
\end{enumerate}
The set of \emph{undesignated values} is $\TVs^- = \TVs\setminus
\TVs^+ = \{\NDTVss\}$.
\end{definition}


%%% ***
%%% Since we are now definitely distinguishing between prop and non-prop
%%% logics the lines for no operators/no quantifiers have been removed
%%% resp. commented out for now.

% ----------- The Operators ------------
\ifnum\NoOps=0
   \ifnum\NoQus=0
%      It is a very simple logic, as it contains neither
%      operators nor quantifiers.
   \else
%      It contains no operators.
   \fi
\else
   The truth function\PS{\NoOps} for connective\PS{\NoOps}
   $\Opname1$%
   \FOR \n=2 \TO \NoOps \DO
      \ifnum\n=\NoOps
         ~and~%
      \else
         ,
      \fi
      $\Opname\n$%
   \ENDFOR\
   \ARE{\NoOps} defined by
   \begin{center}
      $\Optab1$
      \FOR \n=2 \TO \NoOps \DO
         \qquad
         $\Optab\n$
      \ENDFOR
   \end{center}
\fi
% ----------- The Quantifiers ------------
\ifnum\NoQus=0
   \ifnum\NoOps=0
   \else
%      The \NameOfLogic{} is purely propositional: it contains no
%      quantifiers.
   \fi
\else
   The truth function\PS{\NoQus} for quantifier\PS{\NoQus}
   $\Quname1$%
   \FOR \n=2 \TO \NoQus \DO
      \ifnum\n=\NoQus
         ~and~%
      \else
         ,
      \fi
      $\Quname\n$%
   \ENDFOR\
   \ARE{\NoQus} defined by
   \begin{center}
      $\Qutab1$
      \FOR \n=2 \TO \NoQus \DO
         \qquad
         $\Qutab\n$
      \ENDFOR
   \end{center}
\fi


%%% Structure, Interpretation, Satisfiability

\ifprop
   \begin{definition}
   Let $A$ be a formula and $x_0, x_1, \ldots, x_k$ the variables occurring
   in $A$. Then an \emph{interpretation\/} \I\ of $A$ is an assignment of truth
   values to the variables.
   \end{definition}

   \ifnum\NoOps>0
      \begin{definition}
      Given an interpretation \I, we define the \emph{valuation\/} $\val_{\I}$
      for formulas~$A$ to truth values as follows:
      \begin{enumerate}
      \item If $A$ is atomic, then $\val_{\I}(A)$ simply is the interpretation
            of $A$.
      \item If $A=\operator(A_1,\ldots,A_n)$,
            where $A_1,\ldots,A_n$ are formulas, and $\toperator$ is the
            associated truth function to $\operator$, then
            $\val_{\I}(A)=\toperator\bigl(\val_{\I}(A_1),\ldots,\val_{\I}(A_n)\bigr)$.
      \end{enumerate}
      \end{definition}
   \fi

   \begin{definition}
   An interpretation~\I{} \emph{satisfies} a formula $A$, in symbols:
   $\I\models A$, iff $\val_{\I}(A)\in \TVs^+$. 
   \end{definition}
   
   \begin{definition}
   $\Delta$ \emph{entails}~$A$ iff  $\I \models A$ for every
   interpretation~\I{} such that $\I \models B$ for all~$B \in
   \Delta$. $A$~is a \emph{tautology} iff it is satisfied by every
   interpretation~\I.
   \end{definition}
\else
   \begin{definition}
   A \emph{structure\/} $\M = \langle D,\Phi_{\M}\rangle$ for
   a language~\LL\ (an~\LL-structure) consists of the following:
   \begin{enumerate}
   \item A nonempty set $D$, called the \emph{domain\/} (elements of $D$
         are called \emph{individuals}).
   \item A mapping $\Phi_{\M}$ satisfying the following:
         \begin{enumerate}
         \item Each free variable of \LL\ is mapped to an element of $D$.
         \item Each $n$-ary function symbol $f$ of \LL\ is mapped to a
               function $f_{\M}:D^n \to D$, or to an element of $D$ if $n=0$.
               Additionally, $\Phi_{\M}$ maps elements of $D$ to themselves.
         \item Each $n$-ary predicate symbol $P$ of \LL\ is mapped to a
               function $P_{\M}\colon D^n \to \TVs$, or to a element of $\TVs$ if $n=0$.
         \end{enumerate}
   \end{enumerate}
   \end{definition}

   \begin{definition}
   Let \M\ be an \LL-structure. An \emph{assignment\/}~$s$ is a mapping from
   the free variables of \LL to individuals.

   An \emph{interpretation} $\I=\langle \M,s\rangle$ is an \LL-structure
   $\M = \langle D,\Phi_{\M}\rangle$ together with an assignment $s$.
   The mapping $\Phi_{\M}$ can be extended in the obvious way to a mapping
   $\Phi_{\I}$ from terms to individuals:
   \begin{enumerate}
   \item If $t$ is a free variable, then $\Phi_{\I}\colon = s(t)$.
   \item If $t$ is of the form $f(t_1,\ldots,t_k)$, where $f$ is a $k$-ary
         function symbol and $t_1,\ldots,t_k$ are terms, then
         $\Phi_{\I} := f_{\M}\bigl(\Phi_{\I}(t_1),\ldots,\Phi_{\I}(t_k)\bigr)$.
   \end{enumerate}
   \end{definition}

   \begin{definition}
   Given an interpretation $\I=\langle \M,s\rangle$, we define the
   \emph{valuation\/} $\val_{\I}$ for formulas\ $A$ to truth values as follows:
   \begin{enumerate}
   \item If $A$ is atomic, $A=P(t_1,\ldots,t_n)$, where $P$ is
         an $n$-ary predicate symbol and $t_1,\ldots,t_n$ are terms, then let
         $\val_{\I}(A)=P_{\M}\bigl(\Phi_{\I}(t_1),\ldots,\Phi_{\I}(t_n)\bigr)$.
   \ifnum\NoOps>0
      \item If $A=\operator(A_1,\ldots,A_n)$,
            where $A_1,\ldots,A_n$ are formulas, and $\toperator$ is the
            associated truth function to $\operator$, then
            $\val_{\I}(A)=\toperator\bigl(\val_{\I}(A_1),\ldots,\val_{\I}(A_n)\bigr)$.
   \fi
   \item If $A=(\quantor x)(B(x))$, and $\tquantor$ is the
         associated truth function to $\quantor$, then
         $\val_{\I}(A)=\widetilde\quantor\bigl\{\val_{\I}(B(d))|d\in D\}\bigr)$.
   \end{enumerate}
   \end{definition}

   \begin{definition}
   An interpretation~\I{} \emph{satisfies} a formula $A$, in symbols:
   $\I\models A$, iff $\val_{\I}(A)\in \TVs^+$. 
   \end{definition}

   \begin{definition}
   $\Delta$ \emph{entails}~$A$ iff  $\I \models A$ for every
   interpretation~\I{} such that $\I \models B$ for all~$B \in
   \Delta$. $A$~is \emph{valid} iff it is satisfied by every
   interpretation~\I.
   \end{definition}
\fi


\section{Sequent calculus for \NameOfLogic}\label{sec:sequent}


%%% Syntax & Semantics of Sequents, Sequent Calculus

\begin{definition}[Syntax of Sequents]
A \emph{sequent $\Gamma$\/} is
\ifnum\NoTVs=2
   an ordered pair
\else \ifnum\NoTVs=3
      a triple
\else \ifnum\NoTVs=4
   a quadruple
\else
   a $\NoTVs$-tuple
\fi
\fi
\fi
%%% Idea: If we are dealing with excessively many TVs, we could insert
%%% some dots instead of listing them all.
$\Gamma_{\TV1} \FOR\n=2 \TO \NoTVs \DO \mid \Gamma_{\TV\n} \ENDFOR$,
of finite sequences~$\Gamma_v$ of formulas, where $v \in \TVs$.
The $\Gamma_v$ are called the \emph{components} of $\Gamma$.

For a sequence of formulas~$\Delta$, and $W \subseteq \TVs$,
let $[W\colon \Delta]$ denote the sequent
whose component $\Gamma_v$ is~$\Delta$ if $v \in W$ and empty otherwise.
For $[\{w_1,\ldots, w_k\}\colon \Delta]$ we also write
$[w_1,\ldots, w_k\colon \Delta]$.
If $\Gamma$ and $\Gamma'$ are sequents, then $\Gamma, \Gamma'$ denotes the
sequent $\Gamma_{\TV1},\Gamma'_{\TV1} \mid \ifnum\NoTVs>2 \ldots \mid \fi
\Gamma_{\TV\NoTVs},\Gamma'_{\TV\NoTVs}$.
\end{definition}

\begin{definition}
Let \I\ be an interpretation. \I\ \emph{satisfies\/} a sequent~$\Gamma$ iff
there is a $v \in \TVs$ so that for some formula $A \in \Gamma_v$,
$\val_\I(F) = v$.  \I~is called a \emph{model\/}
of $\Gamma$, in symbols $\I \models \Gamma$.

$\Gamma$ is called \emph{satisfiable\/} iff there is an interpretation \I\
so that $\I \models \Gamma$ and \emph{valid\/} iff for every interpretation
\I, $\I \models \Gamma$.
\end{definition}

\begin{proposition}
   $\Delta \models A$ iff the sequent $[\NDTVss\colon \Delta],
   [\DTVss\colon A]$ is valid.
\end{proposition}

\begin{definition}
The \emph{sequent calculus} for \NameOfLogic{} is given by:
\begin{enumerate}
\item axiom schemas of the form $[\TVs \colon A]$,  % 1
\item weakening rules for every truth value~$v$:       % 2
      \[
         \infer[$\textsc{w}:$v]{\Gamma, [v \colon A]}{\Gamma}
      \]
\item exchange rules for every truth value~$v$:        % 3
      \[
         \infer[$\textsc{x}:$v]{\Gamma, [v \colon B, A], \Delta}
               {\Gamma, [v \colon A, B], \Delta}
      \]
\item contraction rules for every truth value~$v$:     % 4
      \[
         \infer[$\textsc{c}:$v]{\Gamma, [v \colon A]}{\Gamma, [v \colon A, A]}
      \]
\item cut rules for every two truth values $v \neq w$:        % 5
      \[
         \infer[$\textsc{cut}:$vw]{\Gamma, \Delta}
               {\Gamma, [v \colon A] & \Delta, [w \colon A]}
      \]
\ifnum\NoOps>0
   \item an introduction rule~$\operator \colon v$ for every
         connective~\operator\ and every truth value $v$,
         as specified \ifnum\NoQus>0 below, \else below. \fi  % 6
\fi
\ifnum\NoQus>0
   \item an introduction rule~$\quantor \colon v$ for every
         quantifier~\quantor\ and every truth value $v$,
         as specified below,
         where the free variables~$\alpha$ occurring in the
         upper sequents satisfy the so-called \emph{eigenvariable condition}:
         No $\alpha$ occurs in the lower sequent.
\fi
\end{enumerate}                                  % 7
(2)--(5) are called \emph{structural rules}.
\ifnum\NoOps>0
   \ifnum\NoQus>0
      (6) and (7) are
   \else
      (6) are
   \fi
   called \emph{logical rules}.
\else
   \ifnum\NoQus>0
      (6) are called \emph{logical rules}.
   \fi
\fi
\end{definition}


\FOR \op=1 \TO \NoOps \DO
   {\noindent
    The introduction rules for connective $\Opname\op$ are given by
    \begin{center}
       \let\rulesep\relax
       \FOR \tv=1 \TO \NoTVs \DO
          \rulesep
          \def\rulesep{\\[2ex]}%
          \makebox[0pt]{\infer[\Opname\op{:}\TV\tv]{\Opconcl{\op}{\tv}}{\Opprems{\op}{\tv}}}%
       \ENDFOR
    \end{center}%
   }
\ENDFOR
\FOR \qu=1 \TO \NoQus \DO
   {\noindent
    The introduction rules for quantifier $\Quname\qu$ are given by
    \begin{center}
       \let\rulesep\relax
       \FOR \tv=1 \TO \NoTVs \DO
          \rulesep
          \def\rulesep{\\[2ex]}%
          \makebox[0pt]{\infer[\Quname\qu{:}\TV\tv]{\Quconcl{\qu}{\tv}}{\Quprems{\qu}{\tv}}}%
       \ENDFOR
    \end{center}%
   }
\ENDFOR


%%% Proofs, Theorems

\begin{definition}
An upward tree of sequents is called a \emph{proof} in the sequent
calculus iff every leaf is \ifnotprop an instance of \fi an axiom, and
all other sequents in it are obtained from the ones standing
immediately above it by applying one of the rules. The sequent at the
root of~$P$ is called its \emph{end-sequent}. A sequent~$\Gamma$ is
called \emph{provable} iff it is the end-sequent of some proof.
\end{definition}

\begin{theorem}
A sequent is provable if and only if it is valid.
\end{theorem}

\begin{proof}
   See Theorems 3.1 and 3.2 of \citet{BaazFermullerZach1994} or
   Theorems 3.3.8 and~3.3.10 of \citet{Zach1993}.
\end{proof}

\begin{corollary}
   In \NameOfLogic, $\models A$ iff $[\DTVss\colon A]$ has a
   sequent proof, and $\Delta \models A$ iff $[\NDTVss\colon \Delta],
   [\DTVss\colon A]$ has a proof.
\end{corollary}

\begin{theorem}
   The cut rule is eliminable in the sequent calculus for
   \NameOfLogic.
\end{theorem}

\begin{proof}
See Theorem 4.1 of \citet{BaazFermullerZach1994} or Theorem 3.5.3 of
\citet{Zach1993}.
\end{proof}

\section{Tableaux for \NameOfLogic}\label{sec:tableaux}

Although the method of \citet{Surma1977} and \citet{Carnielli1987} for
obtaining signed analytic tableaux systems applies to \NameOfLogic, it
has a drawback.  As \citet{Hahnle1993} pointed out, to show that a
formula is valid, it is required to provide as many closed tableaux as
there are non-designated values.  This is usually not desirable; the
generalized approach by \citet{Hahnle1993} solves this problem. Below
we give a tableau system for \NameOfLogic{} using the sets of signs
$\TVs \setminus \{v\}$, i.e., the tableau system exactly dual to that
of Carnielli (in the sense of \cite{BaazFermullerZach1993}).

\begin{definition}
   A \emph{signed formula} is an expression of the form $v \colon A$
   where $v \in \TVs$ and $A$ is a formula.
\end{definition}

\begin{definition}
   A \emph{tableau} for a set of signed formulas $\Delta$ is a
   downward rooted tree of signed formulas where each one is either an
   element of $\Delta$ or results from a signed formula in the branch
   above it by a branch extension rule. A tableau is \emph{closed} if
   every branch contains, for some formula $A$, the signed formulas $v
   \colon A$ for all $v \in \TVs$, or a signed formula $v \colon A$
   with a branch expansion rule that explicitly closes the branch
   ($\otimes$). 
\end{definition}

\FOR \op=1 \TO \NoOps \DO
   {\noindent
    The branch expansion rules for connective $\Opname\op$ are given by
    \begin{center}
       \let\rulesep\relax
       \FOR \tv=1 \TO \NoTVs \DO%
       \ifthenelse{\equal{\TabOpconcl{\op}{\tv}}{}}{}{%
          \rulesep
          \def\rulesep{\\[2ex]}%
          \makebox[0pt]{%
		    $\begin{array}[t]{@{}c@{}}
              \TabOpprem{\op}{\tv} \\ \hline
              \TabOpconcl{\op}{\tv} 
            \end{array}$}}%
       \ENDFOR
    \end{center}%
   }
\ENDFOR
\FOR \qu=1 \TO \NoQus \DO
   {\noindent
    The branch extension rules rules for quantifier $\Quname\qu$ are given by
    \begin{center}
       \let\rulesep\relax
       \FOR \tv=1 \TO \NoTVs \DO
          \rulesep
          \def\rulesep{\\[2ex]}%
          \makebox[0pt]{%
            $\begin{array}[t]{@{}c@{}}
              \TabQuprem{\qu}{\tv} \\ \hline
              \TabQuconcl{\qu}{\tv}
            \end{array}$}%
       \ENDFOR
    \end{center}%
   }
\ENDFOR


\begin{definition}
   An interpretation $\I$ \emph{satisfies} a signed formula $v\colon
   A$ iff $\val_\I(A) \neq v$. A set of signed formulas is
   \emph{satisfiable} if some interpretation~$\I$ satisfies all signed
   formulas in it.
\end{definition}

\begin{theorem}
   A set of signed formulas is unsatisfiable iff it has a closed tableau.
\end{theorem}

\begin{proof}
   Apply Theorems 4.14 and 4.21 of \citet{Hahnle1993}; interpreting $v
   \colon A$ as $\textsf{S}\ A$ where $\mathsf{S} = \TVs \setminus
   \{v\}$.
\end{proof}

\begin{corollary}
   In \NameOfLogic, $\models A$ iff $\{v \colon A \mid v \in
   \TVs^+\}$ has a closed tableau. $\Delta \models A$ iff
   $\{v \colon B \mid v \in \TVs^-, B \in \Delta\} \cup \{v \colon A
   \mid v \in \TVs^+\}$ has a closed tableau.
\end{corollary}

\section{Natural deduction for \NameOfLogic}\label{sec:natural}


%%% Natural Deduction Systems, Formulation

Let $\Gamma$ be a (set) sequent, $\TVs^+ \subseteq \TVs$ the set of
\emph{designated truth values}.  The set of non-designated truth values is then
$\TVs^- = \TVs\setminus \TVs^+$.  We divide the sequent $\Gamma$ into its
designated part $\Gamma^+$ and its non-designated part $\Gamma^-$ in
the obvious way:
\begin{eqnarray*}
   \Gamma^+ & := & \langle \Gamma_v \mid v \in \TVs^+ \rangle \\
   \Gamma^- & := & \langle \Gamma_v \mid v \in \TVs^- \rangle
\end{eqnarray*}

\begin{definition}
The \emph{natural deduction rules} for \NameOfLogic{} are given by:
\begin{enumerate}
\item A weakening rule for all $v \in \TVs^+$:
      \[
         \infer[\textsc{w}{:}v]{\Gamma^+, [v \colon A]}{\Gamma^+}
      \]
\ifnum\NoOps>0
   \item For every connective $\Box$ and every truth value $v$ an
         introduction rule $\Box\textsc{i}{:}v$ (if $v \in \TVs^+$) or an elimination
         rule $\Box\textsc{e}{:}v$ (if $v \in \TVs^-$).
\fi
\ifnum\NoQus>0
   \item For every quantifier \quantor\ and every truth value $v$ an
         introduction rule \quantor$\textsc{i}{:}v$ (if $v \in \TVs^+$) or an
         elimination rule~\quantor:$\textsc{e}{:}v$ (if $v \in \TVs^-$).
\fi
\end{enumerate}
\end{definition}

\FOR \op=1 \TO \NoOps \DO
   {\noindent
    The introduction and elimination rules for connective $\Opname\op$ are given by
    \begin{center}
       \let\rulesep\relax
       \FOR \tv=1 \TO \NoTVs \DO
          \rulesep
          \def\rulesep{\\[2ex]}%
          \makebox[0pt]{%
            \infer[{\Opname\op}{\NDEI\tv} \colon {\TV\tv}]
            {\NDOpconcl{\op}{\tv}}
            {\NDOpprems{\op}{\tv}}}%
       \ENDFOR
    \end{center}%
   }
\ENDFOR
\FOR \qu=1 \TO \NoQus \DO
   {\noindent
    The introduction and elimination rules for quantifier $\Quname\qu$ are given by
    \begin{center}
       \let\rulesep\relax
       \FOR \tv=1 \TO \NoTVs \DO
          \rulesep
          \def\rulesep{\\[2ex]}%
          \makebox[0pt]{%
            \infer[\Quname\qu\NDEI\tv\colon \TV\tv]{\NDQuconcl{\qu}{\tv}}{\NDQuprems{\qu}{\tv}}}%
       \ENDFOR
    \end{center}%
   }
\ENDFOR

%%% Natural Deduction Systems, Misc.

\begin{definition}
A \emph{natural deduction derivation} is defined inductively as follows:
\begin{enumerate}
\item Let $A$ be any formula. Then
      \[
         \infer{ [\TVs^+ \colon A] }{ [\TVs^- \colon A]}
      \]
      is a derivation of $A$ from the assumption $[\TVs^- \colon A]$
      (an \emph{initial derivation}).
\item If $D_k$ are derivations of $\Gamma_k^+, \Delta_k^+$ from the
      assumptions $\Gamma_k^-, \hat{\Delta}_k^-$, and
      \[
         \infer{\Pi^+}
               {\left\langle
               \begin{array}{c}
                  \Gamma_k^-, \lceil \Delta_k^- \rceil \\
                  \Gamma_k^+, \Delta_k^+
               \end{array}
               \right\rangle_{k \in K}}
      \]
      is an instance of a deduction rule with $\hat{\Delta}_k^-$ a
      subsequent of $\Delta_k^-$,
      and all eigenvariable conditions are satisfied, then
      \[
         \infer{\Pi^+}{\langle D_k \rangle_{k \in K}}
      \]
      is a derivation of $\Pi^+$ from the assumptions
      $\bigcup_{k \in K}\Gamma_k^-$.
      The formulas\ in $\hat{\Delta}_k^-$ which do not occur in
      $\bigcup_{k \in K} \Gamma_k^-$
      are said to be \emph{discharged} at this inference.
\end{enumerate}
\end{definition}

\begin{theorem}
A partial sequent $\Gamma^+$ can be derived from the assumptions
$\Gamma^-$ in the natural deduction system for \NameOfLogic{} iff, for
every interpretation~$\I$, either some formula in $\Gamma^-_v$ ($v \in
\TVs^-$) evaluates to the truth value~$v$, or there is a $w \in
\TVs^+$ and a formula in $\Gamma^+_w$ that evaluates to $w$.
\end{theorem}

\begin{proof}
   See Theorems 4.7 and 5.4 of \citet{BaazFermullerZach1993b} or
   Theorems 4.2.8 and 4.3.4 of \citet{Zach1993}.
\end{proof}

\begin{corollary}
   $\Gamma \models A$ iff there is a natural deduction derivation of
   $[\TVs^+ \colon A]$ from $[\TVs^- \colon \Gamma]$.
\end{corollary}


\section{Resolution and clause formation rules for \NameOfLogic}\label{sec:clauses}

The many-valued resolution calculus of \citet{BaazFermuller1995}
applies to \NameOfLogic. We present the framework here, as well
as a language preserving clause translation system for \NameOfLogic.

\begin{definition}[Signed formula]
   A \emph{signed formula} is an expression of the form $A^v$, where
   $A$ is a formula and $v \in \TVs$.  If $A$ is \ifprop a
   propositonal variable\else atomic\fi, $A^v$ is a
   \emph{signed atom}.
\end{definition}

\begin{definition}[Signed clause]
A (signed) \emph{clause~$C = \{ A_1^{v_1}, \ldots,
A_n^{v_n}\}$} is a finite set of signed atoms (proper clause). The
empty clause is denoted by $\Box$.
% The \emph{atom set~at$(C)$} of a clause $C$ is
% the set of its atomic formulas:
% at$(C) = \{A_1, \ldots, A_n\}$.

An \emph{extended clause} is a finite set of signed formulas.
\end{definition}

\begin{definition}[Semantics of clause sets]
\ifprop Let \I\ be an interpretation. \I\ \emph{satisfies\/} a clause~$C$ iff
there is some signed formula $A^v \in C$, so
that $\val_\I(A) = v$. \I\ satisfies a
clause set~$\C$ iff it satisfies every clause in~$\C$.  $\C$~is called
\emph{satisfiable} iff some structure satisfies it, and
\emph{unsatisfiable} otherwise.\else
Let \M\ be a structure. \M\ \emph{satisfies\/} a clause~$C$ iff
for every assignment $s$, there is some signed formula $A^v \in C$, so
that $\val_\I(A) = v$ (where $\I = \langle \M,s\rangle$). \M\ satisfies a
clause set~$\C$ iff it satisfies every clause in~$\C$.  $\C$~is called
\emph{satisfiable} iff some structure satisfies it, and
\emph{unsatisfiable} otherwise.\fi
\end{definition}

\FOR \op=1 \TO \NoOps \DO
   {\noindent
    The clause formation rules for connective $\Opname\op$ are given by
    \begin{center}
       \let\rulesep\relax
       \FOR \tv=1 \TO \NoTVs \DO
          \rulesep
          \def\rulesep{\\[2ex]}%
          \makebox[0pt]{%
            \infer[\Opname\op{:}\TV\tv]%
              {\ClauseSet\ClOpconcl{\op}{\tv}}%
              {\ClauseSet\ClOpprem {\op}{\tv}}}%
       \ENDFOR
    \end{center}%
   }
\ENDFOR
\FOR \qu=1 \TO \NoQus \DO
   {\noindent
    The clause formation rules for quantifier $\Quname\qu$ are given by
    \begin{center}
       \let\rulesep\relax
       \FOR \tv=1 \TO \NoTVs \DO
          \rulesep
          \def\rulesep{\\[2ex]}%
          \makebox[0pt]{%
            \infer[\Quname\qu{:}\TV\tv]%
              {\ClauseSet\ClQuconcl{\qu}{\tv}}%
              {\ClauseSet\ClQuprem {\qu}{\tv}}}%
       \ENDFOR
    \end{center}%
   }
\ENDFOR

\ifnotprop
In the translation rules for quantifiers, the indicated free variables
$b$ are new free variables that do not already occur in the premise,
and terms $f(\vec a)$ are formed using a new function symbol~$f$ and
$\vec a$ all the free variables of the corresponding clause in the
premise.
\fi

\begin{theorem}
Let $T(\C)$ be the result of exhaustively applying the translation rules
to a clause set~$\C$. Then $T(\C)$ is a set of proper clauses, i.e.,
$T(\C)$ contains only signed atoms%
\ifnum\NoOps>0%
   \ifnum\NoQus>0%
      \ (all connectives and quantifiers are eliminated)%
   \else
      \ (all connectives are eliminated)%
   \fi
\else
   \ifnum\NoQus>0%
      \ (all quantifiers are eliminated)%
   \fi
\fi
. Furthermore, $T(\C)$ is satisfiable iff~$\C$ is.
\end{theorem}

\begin{proposition}
   Let $A$ be a sentence and $\Delta$ be a set of sentences. Then
   \begin{enumerate}
      \item $\models A$ iff $\{\{A^v \mid v
      \in \TVs^-\}\}$ is unsatisfiable.
      \item $\Delta \models A$ iff 
      \[\{ \{B^w \mid w \in \TVs^+\} \mid B \in \Delta\} \cup  \{\{A^v \mid v \in
      \TVs^-\}\} \]
      is unsatisfiable.
   \end{enumerate} 
\end{proposition}

\begin{definition}
   A clause $R$ is a \emph{resolvent} of clauses $C_1$, $C_2$ if $R =
   (C_1 \setminus \{A\ifnotprop_1\fi^{v_1}\})\ifnotprop\sigma\fi \cup
   (C_2 \setminus \{A\ifnotprop_2\fi^{v_2}\})\ifnotprop\sigma\fi$ where
   \ifprop $v_1 \neq v_2$\fi
   \ifnotprop
   \begin{enumerate}
      \item $C_1$ and $C_2$ have no free variables in common,
      \item $A_1$ and $A_2$ are unifiable with most general unifier~$\sigma$,
      \item $v_1 \neq v_2$.
   \end{enumerate}
   If $C_1$ and $C_2$ have free variables in common, we say that $R$
   is a resolvent of $C_1$ and $C_2$ if it is a resolvent of
   variable-disjoint renamings $C_1'$ and $C_2'$ of $C_1$ and $C_2$, respectively.
   \fi
\end{definition}

\begin{definition}
   A \emph{resolution refutation} of a clause set $\mathscr{C}$ is a
   sequence of clauses $C_1$, \dots, $C_n$ so that for every $i$, $C_i
   \in \mathscr{C}$ or $C_i$ is a resolvent of $C_j$, $C_k$ with $j, k <
   i$, and $C_n = \emptyset$. 
\end{definition}

\begin{theorem}
   A clause set $\C$ is unsatisfiable iff it has a resolution refutation.
\end{theorem}

\begin{proof}
   See Theorems 3.14 and 3.19 of \citet{BaazFermuller1995} or Theorems 2.5.5 and 2.5.8 of~\citet{Zach1993}.
\end{proof}

\begin{corollary}
   $\Delta \models A$ iff 
      \[T(\{ \{B^w \mid w \in \TVs^+\} \mid B \in \Delta\} \cup  \{\{A^v \mid v \in
      \TVs^-\}\}) \]
   has a resolution refutation.
\end{corollary}

\nocite{*}
\IfFileExists{\jobname.bib}
   {\nocite{ml}\bibliography{ml,\jobname}}
   {\bibliography{ml}}

\appendix

\section{\jobname.lgc~-- specification of \NameOfLogic}\label{lgc}
\lstinputlisting[basicstyle=\footnotesize\ttfamily,breaklines]{\jobname.lgc.stripped}

\IfFileExists{\jobname.cfg}{%
  \section{\jobname.cfg~-- \LaTeX\ translations}\label{cfg}
  \lstinputlisting[basicstyle=\footnotesize\ttfamily,breaklines]{\jobname.cfg}
}{}

\end{document}

